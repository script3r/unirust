syntax = "proto3";

package unirust;

message RecordIdentity {
  string entity_type = 1;
  string perspective = 2;
  string uid = 3;
}

message RecordDescriptor {
  string attr = 1;
  string value = 2;
  int64 start = 3;
  int64 end = 4;
}

message RecordInput {
  uint32 index = 1;
  RecordIdentity identity = 2;
  repeated RecordDescriptor descriptors = 3;
}

message IngestRecordsRequest {
  repeated RecordInput records = 1;
}

message IngestRecordsChunk {
  repeated RecordInput records = 1;
}

message IngestAssignment {
  uint32 index = 1;
  uint32 shard_id = 2;
  uint32 record_id = 3;
  uint32 cluster_id = 4;
  string cluster_key = 5;
}

message IngestRecordsResponse {
  repeated IngestAssignment assignments = 1;
}

message QueryDescriptor {
  string attr = 1;
  string value = 2;
}

message QueryEntitiesRequest {
  repeated QueryDescriptor descriptors = 1;
  int64 start = 2;
  int64 end = 3;
}

message GoldenDescriptor {
  string attr = 1;
  string value = 2;
  int64 start = 3;
  int64 end = 4;
}

message QueryMatch {
  uint32 shard_id = 1;
  uint32 cluster_id = 2;
  int64 start = 3;
  int64 end = 4;
  string cluster_key = 5;
  string cluster_key_identity = 6;
  repeated GoldenDescriptor golden = 7;
}

message QueryDescriptorOverlap {
  QueryDescriptor descriptor = 1;
  int64 start = 2;
  int64 end = 3;
}

message QueryConflict {
  int64 start = 1;
  int64 end = 2;
  repeated QueryMatch clusters = 3;
  repeated QueryDescriptorOverlap descriptors = 4;
}

message QueryMatches {
  repeated QueryMatch matches = 1;
}

message QueryEntitiesResponse {
  oneof outcome {
    QueryMatches matches = 1;
    QueryConflict conflict = 2;
  }
}

message RecordRef {
  string perspective = 1;
  string uid = 2;
}

message ConflictSummary {
  string kind = 1;
  string attribute = 2;
  int64 start = 3;
  int64 end = 4;
  repeated RecordRef records = 5;
  string cause = 6;
}

message ListConflictsRequest {
  int64 start = 1;
  int64 end = 2;
  string attribute = 3;
}

message ListConflictsResponse {
  repeated ConflictSummary conflicts = 1;
}

message Empty {}

// === Cluster-Aware Sharding Messages ===

// Global cluster ID for cross-shard tracking
message GlobalClusterId {
  uint32 shard_id = 1;    // Owning shard (u16 fits in u32)
  uint32 local_id = 2;    // Local cluster ID within shard
  uint32 version = 3;     // Merge version (u16 fits in u32)
}

// Identity key signature for cluster boundary tracking
message IdentityKeySignature {
  bytes signature = 1;    // 32-byte hash
}

// Entry in the cluster boundary index
message ClusterBoundaryEntry {
  GlobalClusterId cluster_id = 1;
  int64 interval_start = 2;
  int64 interval_end = 3;
  uint32 shard_id = 4;
}

// Boundary metadata for cross-shard exchange
message BoundaryMetadata {
  uint32 shard_id = 1;
  uint64 version = 2;
  repeated BoundaryKeyEntries entries = 3;
}

message BoundaryKeyEntries {
  IdentityKeySignature signature = 1;
  repeated ClusterBoundaryEntry entries = 2;
}

// Request to get boundary metadata from a shard
message GetBoundaryMetadataRequest {
  uint64 since_version = 1;  // Only return updates since this version
}

message GetBoundaryMetadataResponse {
  BoundaryMetadata metadata = 1;
}

// Request to get dirty boundary keys from a shard
message GetDirtyBoundaryKeysRequest {}

message DirtyBoundaryKey {
  IdentityKeySignature signature = 1;
  repeated ClusterBoundaryEntry entries = 2;
}

message GetDirtyBoundaryKeysResponse {
  repeated DirtyBoundaryKey dirty_keys = 1;
  uint32 shard_id = 2;
}

// Request to clear dirty keys after reconciliation
message ClearDirtyKeysRequest {
  repeated IdentityKeySignature keys = 1;
}

message ClearDirtyKeysResponse {
  uint32 keys_cleared = 1;
}

// Request for incremental reconciliation
message ReconcileRequest {
  repeated BoundaryMetadata shard_metadata = 1;
}

message ClusterMerge {
  GlobalClusterId primary = 1;   // Cluster to merge into
  GlobalClusterId secondary = 2; // Cluster to be merged
}

message ReconcileResponse {
  uint32 merges_performed = 1;
  uint32 keys_checked = 2;
  uint32 keys_matched = 3;
  repeated ClusterMerge merges = 4;
  uint32 merge_candidates = 5;      // Total merge candidates evaluated
  uint32 conflicts_blocked = 6;     // Merges blocked due to cross-shard conflicts
}

// Request to apply a cross-shard cluster merge on this shard
message ApplyMergeRequest {
  GlobalClusterId primary = 1;    // Cluster to merge into
  GlobalClusterId secondary = 2;  // Cluster being merged away
}

message ApplyMergeResponse {
  bool success = 1;
  uint32 records_updated = 2;     // Number of records moved to new cluster
  string error = 3;               // Error message if any
}

message IdentityKeyConfig {
  string name = 1;
  repeated string attributes = 2;
}

enum ConstraintKind {
  CONSTRAINT_KIND_UNSPECIFIED = 0;
  UNIQUE = 1;
  UNIQUE_WITHIN_PERSPECTIVE = 2;
}

message ConstraintConfig {
  string name = 1;
  string attribute = 2;
  ConstraintKind kind = 3;
}

message OntologyConfig {
  repeated IdentityKeyConfig identity_keys = 1;
  repeated string strong_identifiers = 2;
  repeated ConstraintConfig constraints = 3;
}

message ApplyOntologyRequest {
  OntologyConfig config = 1;
}

message ApplyOntologyResponse {}

message IngestRecordsFromUrlRequest {
  string url = 1;
}

message StatsRequest {}

message StatsResponse {
  uint64 record_count = 1;
  uint64 cluster_count = 2;
  uint64 conflict_count = 3;
  uint64 graph_node_count = 4;
  uint64 graph_edge_count = 5;
  // Cross-shard reconciliation stats
  uint64 cross_shard_merges = 6;        // Successful cross-shard merges
  uint64 cross_shard_conflicts = 7;     // Cross-shard merges blocked by conflicts
  uint64 boundary_keys_tracked = 8;     // Boundary keys for cross-shard detection
}

message HealthCheckRequest {}

message HealthCheckResponse {
  string status = 1;
}

message ConfigVersionRequest {}

message ConfigVersionResponse {
  string version = 1;
}

message CheckpointRequest {
  string path = 1;
}

message CheckpointResponse {
  repeated string paths = 1;
}

message LatencyMetrics {
  uint64 count = 1;
  uint64 total_micros = 2;
  uint64 max_micros = 3;
}

message StoreMetrics {
  bool persistent = 1;
  uint64 running_compactions = 2;
  uint64 running_flushes = 3;
  uint64 block_cache_capacity_bytes = 4;
  uint64 block_cache_usage_bytes = 5;
}

message MetricsRequest {}

message MetricsResponse {
  uint64 uptime_seconds = 1;
  uint64 ingest_requests = 2;
  uint64 ingest_records = 3;
  uint64 query_requests = 4;
  LatencyMetrics ingest_latency = 5;
  LatencyMetrics query_latency = 6;
  StoreMetrics store = 7;
  uint32 shards_reporting = 8;
}

message RecordSnapshot {
  uint32 record_id = 1;
  RecordIdentity identity = 2;
  repeated RecordDescriptor descriptors = 3;
}

message RecordIdRangeRequest {}

message RecordIdRangeResponse {
  bool empty = 1;
  uint32 min_id = 2;
  uint32 max_id = 3;
  uint64 record_count = 4;
}

message ExportRecordsRequest {
  uint32 start_id = 1;
  uint32 end_id = 2;
  uint32 limit = 3;
}

message ExportRecordsResponse {
  repeated RecordSnapshot records = 1;
  bool has_more = 2;
  uint32 next_start_id = 3;
}

message ExportRecordsChunk {
  repeated RecordSnapshot records = 1;
  bool has_more = 2;
  uint32 next_start_id = 3;
}

message ImportRecordsRequest {
  repeated RecordSnapshot records = 1;
}

message ImportRecordsChunk {
  repeated RecordSnapshot records = 1;
}

message ImportRecordsResponse {
  uint64 imported = 1;
}

message RouterRecordIdRangeRequest {
  uint32 shard_id = 1;
}

message RouterExportRecordsRequest {
  uint32 shard_id = 1;
  uint32 start_id = 2;
  uint32 end_id = 3;
  uint32 limit = 4;
}

message RouterImportRecordsRequest {
  uint32 shard_id = 1;
  repeated RecordSnapshot records = 2;
}

service ShardService {
  rpc SetOntology(ApplyOntologyRequest) returns (ApplyOntologyResponse);
  rpc IngestRecords(IngestRecordsRequest) returns (IngestRecordsResponse);
  rpc IngestRecordsStream(stream IngestRecordsChunk) returns (IngestRecordsResponse);
  rpc IngestRecordsFromUrl(IngestRecordsFromUrlRequest) returns (IngestRecordsResponse);
  rpc QueryEntities(QueryEntitiesRequest) returns (QueryEntitiesResponse);
  rpc GetStats(StatsRequest) returns (StatsResponse);
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
  rpc GetConfigVersion(ConfigVersionRequest) returns (ConfigVersionResponse);
  rpc Checkpoint(CheckpointRequest) returns (CheckpointResponse);
  rpc GetMetrics(MetricsRequest) returns (MetricsResponse);
  rpc GetRecordIdRange(RecordIdRangeRequest) returns (RecordIdRangeResponse);
  rpc ExportRecords(ExportRecordsRequest) returns (ExportRecordsResponse);
  rpc ExportRecordsStream(ExportRecordsRequest) returns (stream ExportRecordsChunk);
  rpc ImportRecords(ImportRecordsRequest) returns (ImportRecordsResponse);
  rpc ImportRecordsStream(stream ImportRecordsChunk) returns (ImportRecordsResponse);
  rpc ListConflicts(ListConflictsRequest) returns (ListConflictsResponse);
  rpc Reset(Empty) returns (Empty);
  // Cluster-aware sharding RPCs
  rpc GetBoundaryMetadata(GetBoundaryMetadataRequest) returns (GetBoundaryMetadataResponse);
  rpc ApplyMerge(ApplyMergeRequest) returns (ApplyMergeResponse);
  // Adaptive reconciliation RPCs
  rpc GetDirtyBoundaryKeys(GetDirtyBoundaryKeysRequest) returns (GetDirtyBoundaryKeysResponse);
  rpc ClearDirtyKeys(ClearDirtyKeysRequest) returns (ClearDirtyKeysResponse);
}

service RouterService {
  rpc SetOntology(ApplyOntologyRequest) returns (ApplyOntologyResponse);
  rpc IngestRecords(IngestRecordsRequest) returns (IngestRecordsResponse);
  rpc IngestRecordsFromUrl(IngestRecordsFromUrlRequest) returns (IngestRecordsResponse);
  rpc QueryEntities(QueryEntitiesRequest) returns (QueryEntitiesResponse);
  rpc GetStats(StatsRequest) returns (StatsResponse);
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
  rpc GetConfigVersion(ConfigVersionRequest) returns (ConfigVersionResponse);
  rpc Checkpoint(CheckpointRequest) returns (CheckpointResponse);
  rpc GetMetrics(MetricsRequest) returns (MetricsResponse);
  rpc GetRecordIdRange(RouterRecordIdRangeRequest) returns (RecordIdRangeResponse);
  rpc ExportRecords(RouterExportRecordsRequest) returns (ExportRecordsResponse);
  rpc ExportRecordsStream(RouterExportRecordsRequest) returns (stream ExportRecordsChunk);
  rpc ImportRecords(RouterImportRecordsRequest) returns (ImportRecordsResponse);
  rpc ImportRecordsStream(stream RouterImportRecordsRequest) returns (ImportRecordsResponse);
  rpc ListConflicts(ListConflictsRequest) returns (ListConflictsResponse);
  rpc Reset(Empty) returns (Empty);
  // Cluster-aware sharding RPCs
  rpc Reconcile(ReconcileRequest) returns (ReconcileResponse);
}
